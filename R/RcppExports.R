# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

rcpparma_hello_world <- function() {
    .Call(`_saoptimality_rcpparma_hello_world`)
}

rcpparma_outerproduct <- function(x) {
    .Call(`_saoptimality_rcpparma_outerproduct`, x)
}

rcpparma_innerproduct <- function(x) {
    .Call(`_saoptimality_rcpparma_innerproduct`, x)
}

rcpparma_bothproducts <- function(x) {
    .Call(`_saoptimality_rcpparma_bothproducts`, x)
}

rcpparma_hello_world2 <- function() {
    .Call(`_saoptimality_rcpparma_hello_world2`)
}

#' Convert selection weights to selection probabilities,
#' 'shaped' by \code{temperature}. such that if \code{temperature} is
#' one, probabilities are simply the weights normalised, and if 
#' \code{temperature} was zero all non-zero weights would have equal probability
#' (although temperature should never reach zero in simulated annealing
#' and so this will actually raise an error.
#' @param w NumericVector. The weights.
#' @param  temperature Double in range (0, 1].
#' @example 
#' get_annealed_prob(c(0.5, 0, 0.2), 0.0)
#' get_annealed_prob(c(0.5, 0, 0.2), 0.5)
#' get_annealed_prob(c(0.5, 0, 0.2), 1.0)
NULL

#' Function for (possibly) getting new state.
#' @param s List, with each element being the state for that group.
#' @param candidates List, with each element being the candidates for that group.
#' @param weights List, with each element being the transition weight matrix for that group. (This will be adjusted to make probabilities.)
#' @param e Function to compute the energy.
#' @param e_s Numeric. Result of \code{e(s)}. If \code{NULL}, this will be computed, but it can be passed in to improve efficiency.
#' @param exclusive Boolean. If TRUE, the returned state can contain the same candidate multiple times.
#' @example 
#' s = list(a = c(1, 2), b = c(1, 2))
#' candidates = list(a = 1:4, b = 1:4)
#' weights = list(a = matrix(1, 4, 4) - diag(4),  b = matrix(1, 4, 4) - diag(4))
#' get_next_state(s, candidates, weights, e = function(x) sum(unlist(x)), temperature = 0.5)
NULL

#' @param a x, y coordinates of first point.
#' @param b x, y coordinates of second point.
euclidean_distance <- function(a, b) {
    .Call(`_saoptimality_euclidean_distance`, a, b)
}

#' Wrap INLA::inla.matern.cov(). Only accepts a single distance (not vectorised at all).
#' @param x The distance between the two points.
matern_corr <- function(nu, kappa, x) {
    .Call(`_saoptimality_matern_corr`, nu, kappa, x)
}

#' @param D N x 2 matrix, with each row being a location.
#' @param X N x N matrix to fill with pairwise distances.
get_dist_matrix <- function(D) {
    .Call(`_saoptimality_get_dist_matrix`, D)
}

#' Do a fast rank-one update of an inverted matrix,
#' using the Shermanâ€“Morrison formula, such that:
#' A^-1 -> (A + u v)^-1
#' @param A_inv n x n matrix, already inverted.
#' @param u n x 1 matrix.
#' @param v n x 1 matrix.
rank_one_update <- function(A_inv, u, v) {
    invisible(.Call(`_saoptimality_rank_one_update`, A_inv, u, v))
}

#' Update a row and column of a matrix.
#' A -> A with row/col j replaced
#' @param want The new column (and row).
#' @param j The row/col of \code{A} to be replaced.
row_col_update_of_matrix <- function(A, want, j) {
    invisible(.Call(`_saoptimality_row_col_update_of_matrix`, A, want, j))
}

#' Efficiently update a matrix's inverse when one of the matrix's 
#' rows and columns is updated.
#' A^-1 -> (A with row/col j replaced)^-1
#' @param want The new column (and row).
#' @param j The row/col of \code{A} to be replaced.
row_col_update_of_inverse <- function(A, A_inv, want, j) {
    invisible(.Call(`_saoptimality_row_col_update_of_inverse`, A, A_inv, want, j))
}

#' Efficiently update both the matrix and its inverse  when one of its 
#' rows and columns is updated.
#' A -> A with row/col j replaced
#' A^-1 -> (A with row/col j replaced)^-1
#' @param want The desired vector to be put in row/col \code{j}.
#' @param j Row/col of A to update, zero-indexed.
row_col_update_of_matrix_and_inverse <- function(A, A_inv, want, j) {
    invisible(.Call(`_saoptimality_row_col_update_of_matrix_and_inverse`, A, A_inv, want, j))
}

#' Choose cells to maximise an optimal experimental design objective,
#' which can involve spatio-temporal covariance. Each location may be specified as
#' belonging to a specific group, and the numbers of locations from each group 
#' may be specified.
#' 
#' Uses simulated annealing, and does the computationally heavy evaluation
#' of the energy function in an efficient manner.
#'
#' @param s The initial state, being some number of integers in the range [0, N-1]. May contain the same number multiple times if \code{exclusive} is \code{false}.
#' @param n_steps The number of simulated annealing steps to take.
#' @param nu; // Matern covariance parameter.
#' @param kappa; // Matern covariance parameter.
#' @param X (N x t) x p matrix of the covariates of ALL the available candidates. Rows must be 
#' organised by unit first then by time, e.g., 
#' id_0 time_0; id_0 time_1; ...; id_0 time_t; id_1; time_0; ...
#' @param D N x 2 matrix of the x, y locations of ALL the available candidates.
#' @param grps Same length as candidates. Each element gives the group of the corresponding element of s.
#' @param weights List, with each element being the transition weights for that group.
#' @param exclusive If \code{false}, the same candidate can be in the state multiple times.
#' @param betas p-length vector. Prior point estimates of regression coefficients, used to compute the weight matrix.
#' @param family 0 for Gaussian link, 1 for logistic link.
#' @param Ds_parameters If this contains any elements, the optimality criterion becomes  
#' D_s. For example: If Ds_parameters is [0, 2], then the 1st and 3rd (note the indexing) elements of 
#' beta are of interest. If Ds_parameters is empty, the optimality criterion is D.
#' @param ar1_rho The temporal autocorrelation.
#' @param t The number of time points.
#' @param s2rf The variance of the random field (which, when multiplied by the correlation of the 
#' random field, produces the covariance of the random field).
choose_cells_cpp <- function(X, D, exclusive, grps, s, nu, kappa, resolution, betas, n_steps, family, Ds_parameters, ar1_rho, t, s2rf) {
    .Call(`_saoptimality_choose_cells_cpp`, X, D, exclusive, grps, s, nu, kappa, resolution, betas, n_steps, family, Ds_parameters, ar1_rho, t, s2rf)
}

